Client <PUB> <topic> data ->
-> XADD prefix.<topic> <data> (Cache) -> Get ID
-> HINCRBY prefix.pub_count <topic> 1
-> REDIS PUBSUB prefix.<topic> <data> (ID from XADD) (Fanout)

ON_REDIS_PUBSUB_EVENT:
-> workers->publish()

Client SUB <topicPattern> <lastIDRcvd/timestamp> <limit>:
-> Find all topics matching pattern in the prefix.pub_count Redis HASH.
-> For each of them do a XRANGE <matchingTopic> [<lastIDRcvd> +] [COUNT <limit>]

class Redis {
  public:
    // XADD prefix.<topic> <data>
    // Also calls _incrTopicPubCount()
    bool cacheMessage(Message& msg, string& storedMessageID);

    // actualLimit = limit / len(topicsSeen)
    vector<string> sendCachedForPattern(connection& conn, const string& topicPattern, string& since, long limit);

    void sendCacheForTopic(connection& conn, const string& topicName, string& since, long limit);

  private:
    void _incrTopicPubCount(const string& topicName);
    vector<string> _getTopicsSeen(const string& topicPattern);
};

--------------------------------------------------------------------------------------------------------

client->read()

http::StateMachine
  ->process()

States:

on_req_complete

http::state::REQ_INCOMPLETE
http::state::REQ_READY


websocket::StateMachine
->process()

http::state::CONTROL_READY
http::state::DATA_READY